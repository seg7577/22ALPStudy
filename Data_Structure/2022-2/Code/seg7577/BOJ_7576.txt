#include <iostream>
#include <queue>
#include <string>
#include <algorithm>
#include <bits/stdc++.h>
#define X first
#define Y second

using namespace std;

int board[1005][1005];
int vis[1005][1005] = {};
int dx[4] = { 1, 0 , -1, 0 };
int dy[4] = { 0, 1, 0, -1 };
int n, m;

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);

	cin >> n >> m; //행과 열 입력
	queue<pair<int, int>> Q; //입력 받으면서 시작점을 잡기 위해 큐 선언
	for (int i = 0; i < m; i++) //토마토 입력
		for (int j = 0; j < n; j++)
		{
			cin >> board[i][j];
			if (board[i][j] == 1)
			{
				Q.push({ i, j });
				//임의의 시작점을 잡기 위해 입력을 받으면서 토마토가 익은 곳에서 무작위 시작하기 위함

				vis[i][j] = 0;//시작점
			}
			else if (board[i][j] == 0)
				vis[i][j] = -1;
		}
	while(!Q.empty())
	{
		auto cur = Q.front();
		//Q.front()는 시작에는 토마토가 있는 칸 그 이후로 부터는 익을 수 있는 칸을 push(),pop()함
		Q.pop();
		// 사면이 -1인 경우 빠져 나와야하므로 pop함
		for (int dir = 0; dir < 4; dir++)
		{
			int nx = cur.X + dx[dir];//현재 x좌표 + 상하좌우 와리가리dx[dir]
			int ny = cur.Y + dy[dir];//현재 y좌표 + 상하좌우 와리가리dy[dir]

			if(nx < 0 || ny < 0 || nx >= m || ny >= n)	continue;
			//범위에서 벗어나는 경우 continue

			if (vis[nx][ny] >= 0)	continue;
			//토마토가 들어 있거나, 칸이 존재한다면 continue함
			
			vis[nx][ny] = vis[cur.X][cur.Y] + 1; //익을 수 있는 칸이라고 판단하고 횟수 판독으로 일수 확인.

			Q.push({ nx, ny });
			//이 과정을 반복하며 익을 수 있는 칸을 찾음
		}
	}

	int num = 0;

	for (int i = 0; i < m; i++)
	{
		for (int j = 0; j < n; j++)
		{
			if (vis[i][j] == -1)
				//아직까지 안 들어간거면 상하좌우 칸이 없는 거임 그러므로 문제 조건대로 -1 출력
			{
				cout << -1;
				return 0;
			}
			num = max(num, vis[i][j]);
		}
	}
	cout << num; //익는 일수 출력

	return 0;
}
