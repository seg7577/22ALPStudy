#include <bits/stdc++.h>
#include <iostream>
#include <queue>

#define X first
#define Y second

//pair가 first와 second를 기반으로 접근하기 때문에 선언
using namespace std;

int board[502][502] = {};
bool vis[502][502]; //방문 여부를 저장하기 위한 bool형 이차원 배열
int n = 7, m = 10; //행과 열의 범위
int dx[4] = { 1, 0, -1, 0 };
int dy[4] = { 0, 1, 0, -1 };

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);

	queue<pair<int, int>> Q;//
	vis[0][0] = 1; //시작점은 1로 표시하고 시작, 과정1, 자주하는 실수 1번 : "시작점에 방문했다는 표시를 남기지 않는다."
	Q.push({ 0, 0 }); //시작점이므로 Q에 넣고 시작, 과정1

	while (!Q.empty())
		//큐가 비면 1을 반환하고 큐가 차있으면 0을 반환 하지만 !을 붙였으니, 비면 0을 반환 차있으면 1을 반환
		//상하좌우 인접한 좌표를 모두 방문했거나, 조건에 충족하지 않을 경우 큐가 비게 되므로 그때 0을 반환할 것이다.
	{
		pair<int, int> cur = Q.front();
		//큐의 과정 2번을 진행하기 위해 pair 선언한 cur에 큐의 front 값을 넣음

		Q.pop(); // 자주하는 실수 2번에서 말한 빼는 경우가 이곳임
		//front 했으면 다음 비교를 위해 cur에 저장한 이후 바로 pop하여 삭제
		cout << '(' << cur.X << ", " << cur.Y << ") -> ";
		
		for (int dir = 0; dir < 4; dir++)
			// dir은 상하좌우로 (x,y) 좌표를 와리가리 치기 위해 반복을 4로 함
		{
			int nx = cur.X + dx[dir];
			int ny = cur.Y + dy[dir];
			//좌표를 상 or 하 or 좌 or 우로 이동시키고 그값을 각각 nx, ny에 저장하여 이후 조건과 비교할 수 있게 만듦

			if (nx < 0 || nx >= n || ny < 0 || ny >= m)	continue;
			//#상하좌우로 이동시킨 좌표값이 혹여나 음수이거나 주어진 n과 m의 값에 벗어나면 바로 continue함 이러기 위해 nx와 ny를 만든 이유1

			if (vis[nx][ny] || board[nx][ny] != 1)	continue;
			//#상하좌우로 이동시킨 좌표값이 혹여나 이미 방문했거나 우리가 원하는 조건에 충족하지 못한 칸이면 바로 continue함  nx와 ny를 만든 이유2

			vis[nx][ny] = 1; //"자주 하는 실수 2 : "큐에 넣을 때 방문했다는 표시를 하는 대신 큐에서 빼낼 때 방문했다는 표시를 남긴 경우" 조심하기, 실수 2번 같은 경우는 메모리 초과 or 시간 초과로 이어지는 경우임
			//위의 2개의 if문의 조건을 불충족하였다면 방문하지 않았고, 우리가 원하는 조건을 충족하고, 좌표의 값이 범위에 벗어나지 않는 것이므로 방문하였단 표시를 남겨주기 위해 vis의 좌표 값에 1을 넣어줌

			Q.push({ nx, ny });
			//이 for문을 빠져 나간 이후 현재 방문한 좌표의 상하좌우를 탐색하기 위해 큐에 저장

		}
	}
}

//자주 하는 실수 3 : "이웃한 원소가 범위를 벗어나는지에 대한 체크를 잘못했다.", 44번째의 if문과 47번째의 if문의 실행 순서를 바꾼다면 예를 들어 vis[-1][0] 이러한 좌표 값을 참조할 수 있어 런타임에러가 날 수 있으므로 일단 범위를 먼저 체크하는 것임
